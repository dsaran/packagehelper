# PlSql Grammar for yapps3
# Version: $Id: plsql.g,v 1.10 2009-04-04 00:16:18 daniel Exp $ 

class SqlStatement(object):
    def __init__(self, id=None, stmt_type=None):
        self.stmt_type = stmt_type
        self.id = id

    def __setattr__(self, name, val):
        self.__dict__[name] = val

    def __getattr__(self, name):
        return self.__dict__[name]

    def __repr__(self):
        c = str(self.__class__)
        d = str(self.__dict__)
        return "\n<%s>\n\t%s\n<%s>"  % (c, d, c)

    def __eq__(self, obj):
        #print 'self.__dict__', self.__dict__
        if obj != None and hasattr(obj, '__dict__'):
            #print 'obj.__dict__', obj.__dict__
            return self.__dict__ == obj.__dict__
        return False

class CallableStatement(SqlStatement):
    """ Represents the call or declaration of a function or procedure.
    A callable has three properties:
    - object: the object receiving the 'message', it is an Identifier
    - name: the name of the method called/declared on the object, it is a string
    - arguments: arguments sent to name, it is a list even if there is no argument
    ex: call the_object.method(arg1, arg2)
    In this example we have:
        object: the_object
        name: method
        arguments: [arg1, arg2]
    """
    def __init__(self, object=None, name=None, arguments=[]):
        """ Constructor
            @param object the object receiving the call.
            @param arguments arguments passed to function/procedure."""
        SqlStatement.__init__(self, stmt_type="CALL", id=name)
        self.object = object
        self.arguments = arguments

    def __getattr__(self, name):
        if name == 'name':
            return self.id
        return SqlStatement.__getattr__(self, name)

    def __setattr__(self, name, val):
        if name == 'name':
            self.id = val
        else:
            SqlStatement.__setattr__(self, name, val)


class InsertStatement(SqlStatement):
    def __init__(self, table=None, columns=[], values=[]):
        SqlStatement.__init__(self, stmt_type="INSERT", id=table)
        self.columns = columns
        self.values = values

    def __setattr__(self, name, val):
        if name == 'table':
            self.id = val
        else:
            SqlStatement.__setattr__(self, name, val)

    def __getattr__(self, name):
        if name == 'table':
            return self.id
        else:
            return SqlStatement.__getattr__(self, name)

class Identifier(SqlStatement):
    def __init__(self, id=None, alias=None, parent=None, type=None):
        SqlStatement.__init__(self, id=id, stmt_type="IDENTIFIER")
        self.parent = parent
        self.alias = alias
        self.type = type 

class Source(SqlStatement):
    def __init__(self, id=None, type=None, members=[]):
        SqlStatement.__init__(self, id=id, stmt_type="SOURCE")
        self.calls = []
        self.type = type
        self.members = members

class RelationalOperation(SqlStatement):
    def __init__(self, op1=None, operator=None, op2=None):
        SqlStatement.__init__(self, id=operator, stmt_type="RELATIONAL")
        self.op1 = op1
        self.op2 = op2

    def __setattr__(self, name, val):
        if name == 'operator':
            self.id = val
        else:
            SqlStatement.__setattr__(self, name, val)

    def __getattr__(self, name):
        if name == 'operator':
            return self.id
        else:
            return SqlStatement.__getattr__(self, name)

class SelectStatement(SqlStatement):
    def __init__(self, columns=None, tables=None, where_clause=None):
        SqlStatement.__init__(self, stmt_type="INSERT")
        self.columns = columns
        self.tables = tables
        self.where_clause = where_clause


# Begin -- grammar generated by Yapps
import sys, re
import yappsrt

class plsqlScanner(yappsrt.Scanner):
    patterns = [
        ("'AND'", re.compile('AND')),
        ("'WHERE'", re.compile('WHERE')),
        ("'FROM'", re.compile('FROM')),
        ("'ALL'", re.compile('ALL')),
        ("'UNIQUE'", re.compile('UNIQUE')),
        ("'DISTINCT'", re.compile('DISTINCT')),
        ("'SELECT'", re.compile('SELECT')),
        ("'WHEN'", re.compile('WHEN')),
        ("'EXCEPTION'", re.compile('EXCEPTION')),
        ('":="', re.compile(':=')),
        ("'ELSE'", re.compile('ELSE')),
        ("'THEN'", re.compile('THEN')),
        ("'IF'", re.compile('IF')),
        ("';'", re.compile(';')),
        ("'/'", re.compile('/')),
        ("'END'", re.compile('END')),
        ("'BEGIN'", re.compile('BEGIN')),
        ('"AS"', re.compile('AS')),
        ('"IS"', re.compile('IS')),
        ("'REPLACE'", re.compile('REPLACE')),
        ("'OR'", re.compile('OR')),
        ("'CREATE'", re.compile('CREATE')),
        ("'VIEW'", re.compile('VIEW')),
        ("'MATERIALIZED'", re.compile('MATERIALIZED')),
        ("'BODY'", re.compile('BODY')),
        ("'PACKAGE'", re.compile('PACKAGE')),
        ("'PROCEDURE'", re.compile('PROCEDURE')),
        ("'FUNCTION'", re.compile('FUNCTION')),
        ("'VALUES'", re.compile('VALUES')),
        ("'INTO'", re.compile('INTO')),
        ("'INSERT'", re.compile('INSERT')),
        ("'>'", re.compile('>')),
        ("'<'", re.compile('<')),
        ("'='", re.compile('=')),
        ("'!'", re.compile('!')),
        ("'\\\\^'", re.compile('\\^')),
        ("'\\\\)'", re.compile('\\)')),
        ("','", re.compile(',')),
        ("'\\\\('", re.compile('\\(')),
        ("'OUT'", re.compile('OUT')),
        ("'IN'", re.compile('IN')),
        ('"\'"', re.compile("'")),
        ('"/"', re.compile('/')),
        ('";"', re.compile(';')),
        ('END', re.compile('[$;]')),
        ('NUM', re.compile('[0-9]+')),
        ('ID', re.compile('[a-zA-Z_][a-zA-Z0-9_-]*')),
        ('SINGLE_QUOTED_STRING', re.compile("[^']*")),
        ('DOT', re.compile('\\.')),
        ('STAR', re.compile('\\*')),
        ('ASSIGNMENT', re.compile(':=')),
        ('\\s+', re.compile('\\s+')),
        ('^(\\s+)*$', re.compile('^(\\s+)*$')),
        ('^(\\s+)*SET.*?\r?\n', re.compile('^(\\s+)*SET.*?\r?\n')),
        ('/\\*(.|\r?\n)+?\\*/', re.compile('/\\*(.|\r?\n)+?\\*/')),
        ('--.*?\r?\n', re.compile('--.*?\r?\n')),
        ('[ \t\r\n]+', re.compile('[ \t\r\n]+')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,['\\s+', '^(\\s+)*$', '^(\\s+)*SET.*?\r?\n', '/\\*(.|\r?\n)+?\\*/', '--.*?\r?\n', '[ \t\r\n]+'],str)

class plsql(yappsrt.Parser):
    Context = yappsrt.Context
    def goal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'goal', [])
        expr = self.expr(_context)
        END = self._scan('END')

    def expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'expr', [])
        _token = self._peek("'INSERT'", "'SELECT'", "'CREATE'")
        if _token == "'INSERT'":
            insert_statement = self.insert_statement(_context)
            _token = self._peek('";"', '"/"')
            if _token == '";"':
                self._scan('";"')
            else: # == '"/"'
                self._scan('"/"')
            return insert_statement
        elif _token == "'SELECT'":
            select_statement = self.select_statement(_context)
            _token = self._peek('";"', '"/"')
            if _token == '";"':
                self._scan('";"')
            else: # == '"/"'
                self._scan('"/"')
            return select_statement
        else: # == "'CREATE'"
            source_declaration = self.source_declaration(_context)
            return source_declaration

    def QUOTED_STRING(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'QUOTED_STRING', [])
        self._scan('"\'"')
        SINGLE_QUOTED_STRING = self._scan('SINGLE_QUOTED_STRING')
        self._scan('"\'"')
        return "'%s'" % SINGLE_QUOTED_STRING

    def LITERAL(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'LITERAL', [])
        _token = self._peek('"\'"', 'NUM')
        if _token == '"\'"':
            QUOTED_STRING = self.QUOTED_STRING(_context)
            return QUOTED_STRING
        else: # == 'NUM'
            NUM = self._scan('NUM')
            return int(NUM)

    def argument(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'argument', [])
        ID = self._scan('ID')
        result = Identifier(id=ID)
        _token = self._peek("'IN'", "'OUT'", 'ID', 'DOT', '"\'"', 'NUM', "','", "'\\\\)'")
        if self._peek("'IN'", "'OUT'", 'DOT', '"\'"', 'NUM', 'ID', "','", "'\\\\)'") in ["'IN'", "'OUT'"]:
            _token = self._peek("'IN'", "'OUT'")
            if _token == "'IN'":
                self._scan("'IN'")
                if self._peek("'OUT'", 'ID') == "'OUT'":
                    self._scan("'OUT'")
            else: # == "'OUT'"
                self._scan("'OUT'")
            ID = self._scan('ID')
            result.type = ID
        else: # in ['DOT', 'NUM', "'\\\\)'"]
            if self._peek('ID', 'DOT', '"\'"', 'NUM', "','", "'\\\\)'") == 'ID':
                ID = self._scan('ID')
                result.type = ID
        _token = self._peek('DOT', '"\'"', 'NUM', 'ID', "','", "'\\\\)'")
        if _token != 'DOT':
            pass
        else: # == 'DOT'
            DOT = self._scan('DOT')
            ID = self._scan('ID')
            result = Identifier(id=ID, parent=result)
        return result

    def identifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'identifier', [])
        ID = self._scan('ID')
        result = Identifier(id=ID)
        _token = self._peek("'IN'", "'OUT'", 'ID', 'DOT', 'ASSIGNMENT', '":="', "';'", "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', "'\\\\^'", "'!'", "'='", "'<'", "'>'", '"\'"', 'NUM', "','", "'\\\\)'", "'THEN'", "'AND'", "'OR'", "'WHERE'", "'FROM'", '";"', '"/"')
        if self._peek("'IN'", "'OUT'", 'DOT', 'ASSIGNMENT', '":="', "';'", "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', "'\\\\^'", "'!'", "'='", "'<'", "'>'", '"\'"', 'NUM', 'ID', "','", "'\\\\)'", "'THEN'", "'AND'", "'OR'", "'WHERE'", "'FROM'", '";"', '"/"') in ["'IN'", "'OUT'"]:
            _token = self._peek("'IN'", "'OUT'")
            if _token == "'IN'":
                self._scan("'IN'")
                if self._peek("'OUT'", 'ID') == "'OUT'":
                    self._scan("'OUT'")
            else: # == "'OUT'"
                self._scan("'OUT'")
            ID = self._scan('ID')
            result.type = ID
        else:
            if self._peek('ID', 'DOT', 'ASSIGNMENT', '":="', "';'", "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', "'\\\\^'", "'!'", "'='", "'<'", "'>'", '"\'"', 'NUM', "','", "'\\\\)'", "'THEN'", "'AND'", "'OR'", "'WHERE'", "'FROM'", '";"', '"/"') == 'ID':
                ID = self._scan('ID')
                result.alias = ID
        _token = self._peek('DOT', 'ASSIGNMENT', '":="', "';'", "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', "'\\\\^'", "'!'", "'='", "'<'", "'>'", '"\'"', 'NUM', 'ID', "','", "'\\\\)'", "'THEN'", "'AND'", "'OR'", "'WHERE'", "'FROM'", '";"', '"/"')
        if _token != 'DOT':
            pass
        else: # == 'DOT'
            DOT = self._scan('DOT')
            _token = self._peek('ID', 'STAR')
            if _token == 'ID':
                ID = self._scan('ID')
                result = Identifier(id=ID, parent=result)
            else: # == 'STAR'
                STAR = self._scan('STAR')
                result = Identifier(id='*', parent=result)
        return result

    def callable(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'callable', [])
        identifier = self.identifier(_context)
        result = identifier
        if self._peek("'\\\\('", "';'", 'END', '"IS"', '"AS"', "'\\\\^'", "'!'", "'='", "'<'", "'>'", '"\'"', 'NUM', 'ID', "','", "'\\\\)'", "'THEN'", "'AND'", "'OR'", "'WHERE'", "'FROM'", '";"', '"/"') == "'\\\\('":
            argument_list = self.argument_list(_context)
            result = CallableStatement(object=identifier.parent, name=identifier.id, arguments=argument_list)
        return result

    def list_value(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'list_value', [])
        _token = self._peek('"\'"', 'NUM', 'ID')
        if _token != 'ID':
            LITERAL = self.LITERAL(_context)
            return LITERAL
        else: # == 'ID'
            callable = self.callable(_context)
            return callable

    def list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'list', [])
        result = []
        self._scan("'\\\\('")
        while self._peek("'\\\\)'", '"\'"', 'NUM', 'ID', "','") != "'\\\\)'":
            _token = self._peek('"\'"', 'NUM', 'ID', "','")
            if _token != "','":
                list_value = self.list_value(_context)
                result.append(list_value)
            else: # == "','"
                self._scan("','")
                list_value = self.list_value(_context)
                result.append(list_value)
        if self._peek() not in ["'\\\\)'", '"\'"', 'NUM', 'ID', "','"]:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\'"', 'NUM', 'ID', "','", "'\\\\)'"]))
        self._scan("'\\\\)'")
        return result

    def simplified_list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'simplified_list', [])
        result = []
        while self._peek('"\'"', 'NUM', 'ID', "','", "'WHERE'", "'FROM'") not in ["'WHERE'", "'FROM'"]:
            _token = self._peek('"\'"', 'NUM', 'ID', "','")
            if _token != "','":
                list_value = self.list_value(_context)
                result.append(list_value)
            else: # == "','"
                self._scan("','")
                list_value = self.list_value(_context)
                result.append(list_value)
        if self._peek() not in ['"\'"', 'NUM', 'ID', "','", "'WHERE'", "'FROM'"]:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\'"', 'NUM', 'ID', "','", "'WHERE'", "'FROM'"]))
        return result

    def argument_list_value(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'argument_list_value', [])
        _token = self._peek('"\'"', 'NUM', 'ID')
        if _token != 'ID':
            LITERAL = self.LITERAL(_context)
            return LITERAL
        else: # == 'ID'
            argument = self.argument(_context)
            return argument

    def argument_list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'argument_list', [])
        result = []
        self._scan("'\\\\('")
        while self._peek("'\\\\)'", '"\'"', 'NUM', 'ID', "','") != "'\\\\)'":
            _token = self._peek('"\'"', 'NUM', 'ID', "','")
            if _token != "','":
                argument_list_value = self.argument_list_value(_context)
                result.append(argument_list_value)
            else: # == "','"
                self._scan("','")
                argument_list_value = self.argument_list_value(_context)
                result.append(argument_list_value)
        if self._peek() not in ["'\\\\)'", '"\'"', 'NUM', 'ID', "','"]:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\'"', 'NUM', 'ID', "','", "'\\\\)'"]))
        self._scan("'\\\\)'")
        return result

    def comparison(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'comparison', [])
        list_value = self.list_value(_context)
        relational_op = self.relational_op(_context)
        result = RelationalOperation(op1=list_value, operator=relational_op)
        list_value = self.list_value(_context)
        result.op2 = list_value
        return result

    def relational_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'relational_op', [])
        _token = self._peek("'\\\\^'", "'!'", "'='", "'<'", "'>'")
        if _token not in ["'='", "'<'", "'>'"]:
            _token = self._peek("'\\\\^'", "'!'")
            if _token == "'\\\\^'":
                self._scan("'\\\\^'")
            else: # == "'!'"
                self._scan("'!'")
            self._scan("'='")
            result = 'NOT_EQ'
        elif _token == "'='":
            self._scan("'='")
            result = 'EQ'
        elif _token == "'<'":
            self._scan("'<'")
            result = 'LT'
            if 1:
                _token = self._peek("'='", "'>'", '"\'"', 'NUM', 'ID')
                if _token not in ["'='", "'>'"]:
                    pass
                elif _token == "'='":
                    self._scan("'='")
                    result = 'LE'
                else: # == "'>'"
                    self._scan("'>'")
                    result = 'NOT_EQ'
        else: # == "'>'"
            self._scan("'>'")
            _token = self._peek("'='", '"\'"', 'NUM', 'ID')
            if _token != "'='":
                result = 'GT'
            else: # == "'='"
                self._scan("'='")
                result = 'GE'
        return result

    def insert_base(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'insert_base', [])
        self._scan("'INSERT'")
        self._scan("'INTO'")
        identifier = self.identifier(_context)
        return identifier

    def insert_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'insert_statement', [])
        sqlobject = InsertStatement()
        insert_base = self.insert_base(_context)
        sqlobject.table = insert_base
        _token = self._peek("'\\\\('", "'VALUES'")
        if _token == "'VALUES'":
            columns = []
        else: # == "'\\\\('"
            list = self.list(_context)
            columns = list
        sqlobject.columns = columns
        self._scan("'VALUES'")
        list = self.list(_context)
        sqlobject.values = list
        return sqlobject

    def object_type(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'object_type', [])
        _token = self._peek("'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'")
        if _token == "'FUNCTION'":
            self._scan("'FUNCTION'")
            result = 'FUNCTION'
        elif _token == "'PROCEDURE'":
            self._scan("'PROCEDURE'")
            result = 'PROCEDURE'
        elif _token == "'PACKAGE'":
            self._scan("'PACKAGE'")
            result = 'PACKAGE'
            if self._peek("'BODY'", 'ID') == "'BODY'":
                self._scan("'BODY'")
                result = 'PACKAGE BODY'
        else: # == "'MATERIALIZED'"
            self._scan("'MATERIALIZED'")
            self._scan("'VIEW'")
            result = 'VIEW'
        return result

    def source_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'source_declaration', [])
        self._scan("'CREATE'")
        if self._peek("'OR'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'") == "'OR'":
            self._scan("'OR'")
            self._scan("'REPLACE'")
        object_type = self.object_type(_context)
        result = Source(type=object_type)
        callable = self.callable(_context)
        result.id = callable
        _token = self._peek('END', '"IS"', '"AS"')
        if _token == 'END':
            END = self._scan('END')
        elif _token == '"IS"':
            self._scan('"IS"')
        else: # == '"AS"'
            self._scan('"AS"')
        result.members = []
        return result

    def full_source_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'full_source_declaration', [])
        source_declaration = self.source_declaration(_context)
        result = source_declaration
        if self._peek("'BEGIN'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'", "'END'") == "'BEGIN'":
            self._scan("'BEGIN'")
        while self._peek("'END'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'") != "'END'":
            object_type = self.object_type(_context)
            member = Source(type=object_type)
            callable = self.callable(_context)
            member.id = callable
            _token = self._peek('END', '"IS"')
            if _token == 'END':
                END = self._scan('END')
            else: # == '"IS"'
                self._scan('"IS"')
                block = self.block(_context)
                member.calls += block
            result.members.append(member)
        if self._peek() not in ["'END'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'"]:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(["'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'", "'END'"]))
        self._scan("'END'")
        ID = self._scan('ID')
        if self._peek('END', "'/'") == 'END':
            END = self._scan('END')
        self._scan("'/'")
        return result

    def block(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'block', [])
        calls = []
        _token = self._peek("'BEGIN'", "'IF'", 'ID', "'EXCEPTION'", "'WHEN'")
        if _token == "'BEGIN'":
            self._scan("'BEGIN'")
            block = self.block(_context)
            self._scan("'END'")
            if self._peek('ID', "';'", "'WHEN'", "'END'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'") == 'ID':
                ID = self._scan('ID')
            if self._peek("';'", "'WHEN'", "'END'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'") == "';'":
                self._scan("';'")
            calls += block
        elif _token == "'IF'":
            self._scan("'IF'")
            comparison = self.comparison(_context)
            self._scan("'THEN'")
            executable_code = self.executable_code(_context)
            calls += executable_code
            if self._peek("'ELSE'", "'END'") == "'ELSE'":
                self._scan("'ELSE'")
                executable_code = self.executable_code(_context)
                calls += executable_code
            self._scan("'END'")
            self._scan("'IF'")
        elif _token != 'ID':
            exception_handling = self.exception_handling(_context)
        else: # == 'ID'
            if 1:
                identifier = self.identifier(_context)
                ASSIGNMENT = self._scan('ASSIGNMENT')
            callable = self.callable(_context)
            self._scan("';'")
            calls.append(callable)
        return calls

    def executable_code(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'executable_code', [])
        _token = self._peek('ID')
        calls = []
        callable = self.callable(_context)
        self._scan("';'")
        calls.append(callable)
        return calls

    def exception_handling(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'exception_handling', [])
        _token = self._peek("'EXCEPTION'", "'WHEN'")
        if _token == "'EXCEPTION'":
            self._scan("'EXCEPTION'")
            ID = self._scan('ID')
            self._scan("'THEN'")
        else: # == "'WHEN'"
            while 1:
                self._scan("'WHEN'")
                ID = self._scan('ID')
                block = self.block(_context)
                if self._peek("'WHEN'", "'END'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'", "'MATERIALIZED'") != "'WHEN'": break

    def select_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'select_statement', [])
        self._scan("'SELECT'")
        select = SelectStatement()
        if self._peek("'DISTINCT'", "'UNIQUE'", "'ALL'", 'STAR', '"\'"', 'NUM', 'ID', "','", "'FROM'", "'WHERE'") in ["'DISTINCT'", "'UNIQUE'", "'ALL'"]:
            _token = self._peek("'DISTINCT'", "'UNIQUE'", "'ALL'")
            if _token == "'DISTINCT'":
                self._scan("'DISTINCT'")
            elif _token == "'UNIQUE'":
                self._scan("'UNIQUE'")
            else: # == "'ALL'"
                self._scan("'ALL'")
        query_columns = self.query_columns(_context)
        select.columns = query_columns
        self._scan("'FROM'")
        simplified_list = self.simplified_list(_context)
        select.tables = simplified_list
        where_clause = self.where_clause(_context)
        select.where_clause = where_clause
        return select

    def query_columns(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'query_columns', [])
        _token = self._peek('STAR', '"\'"', 'NUM', 'ID', "','", "'WHERE'", "'FROM'")
        if _token == 'STAR':
            STAR = self._scan('STAR')
            result = STAR
        else: # in ['"\'"', 'NUM', 'ID', "','", "'WHERE'", "'FROM'"]
            simplified_list = self.simplified_list(_context)
            result = simplified_list
        return result

    def where_clause(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'where_clause', [])
        self._scan("'WHERE'")
        conditions = []
        while 1:
            _token = self._peek('"\'"', 'NUM', 'ID', "'AND'", "'OR'")
            if _token not in ["'AND'", "'OR'"]:
                comparison = self.comparison(_context)
                conditions.append(comparison)
            else: # in ["'AND'", "'OR'"]
                _token = self._peek("'AND'", "'OR'")
                if _token == "'AND'":
                    self._scan("'AND'")
                else: # == "'OR'"
                    self._scan("'OR'")
                comparison = self.comparison(_context)
                conditions.append(comparison)
            if self._peek('"\'"', 'NUM', 'ID', "'AND'", "'OR'", '";"', '"/"') not in ['"\'"', 'NUM', 'ID', "'AND'", "'OR'"]: break
        return conditions


def parse(rule, text):
    P = plsql(plsqlScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps



