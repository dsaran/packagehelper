# PlSql Grammar for yapps3
# Version: $id$ 

class SqlStatement(object):
    def __init__(self, id=None, stmt_type=None):
        self.stmt_type = stmt_type
        self.id = id

    def __setattr__(self, name, val):
        self.__dict__[name] = val

    def __getattr__(self, name):
        return self.__dict__[name]

    def __repr__(self):
        return str(self.__dict__)

    def __eq__(self, obj):
        #print 'self.__dict__', self.__dict__
        if obj != None:
            #print 'obj.__dict__', obj.__dict__
            return self.__dict__ == obj.__dict__
        return False

class CallableStatement(SqlStatement):
    """ Represents the call or declaration of a function or procedure.
    A callable has three properties:
    - object: the object receiving the 'message', it is an Identifier
    - name: the name of the method called/declared on the object, it is a string
    - arguments: arguments sent to name, it is a list even if there is no argument
    ex: call the_object.method(arg1, arg2)
    In this example we have:
        object: the_object
        name: method
        arguments: [arg1, arg2]
    """
    def __init__(self, object=None, name=None, arguments=[]):
        """ Constructor
            @param object the object receiving the call.
            @param arguments arguments passed to function/procedure."""
        SqlStatement.__init__(self, stmt_type="CALL", id=name)
        self.object = object
        self.arguments = arguments

    def __getattr__(self, name):
        if name == 'name':
            return self.id
        return SqlStatement.__getattr__(self, name)

    def __setattr__(self, name, val):
        if name == 'name':
            self.id = val
        else:
            SqlStatement.__setattr__(self, name, val)


class InsertStatement(SqlStatement):
    def __init__(self, table=None, columns=[], values=[]):
        SqlStatement.__init__(self, stmt_type="INSERT", id=table)
        self.columns = columns
        self.values = values

    def __setattr__(self, name, val):
        if name == 'table':
            self.id = val
        else:
            SqlStatement.__setattr__(self, name, val)

    def __getattr__(self, name):
        if name == 'table':
            return self.id
        else:
            return SqlStatement.__getattr__(self, name)

class Identifier(SqlStatement):
    def __init__(self, id=None, alias=None, parent=None, type=None):
        SqlStatement.__init__(self, id=id, stmt_type="IDENTIFIER")
        self.parent = parent
        self.alias = alias
        self.type = type 

class Source(SqlStatement):
    def __init__(self, id=None, type=None):
        SqlStatement.__init__(self, id=id, stmt_type="SOURCE")
        self.type = type


# Begin -- grammar generated by Yapps
import sys, re
import yappsrt

class plsqlScanner(yappsrt.Scanner):
    patterns = [
        ('"AS"', re.compile('AS')),
        ('"IS"', re.compile('IS')),
        ("'REPLACE'", re.compile('REPLACE')),
        ("'OR'", re.compile('OR')),
        ("'CREATE'", re.compile('CREATE')),
        ("'BODY'", re.compile('BODY')),
        ("'PACKAGE'", re.compile('PACKAGE')),
        ("'PROCEDURE'", re.compile('PROCEDURE')),
        ("'FUNCTION'", re.compile('FUNCTION')),
        ("'VALUES'", re.compile('VALUES')),
        ("'INTO'", re.compile('INTO')),
        ("'INSERT'", re.compile('INSERT')),
        ("'\\\\)'", re.compile('\\)')),
        ("','", re.compile(',')),
        ("'\\\\('", re.compile('\\(')),
        ('"\'"', re.compile("'")),
        ("'OUT'", re.compile('OUT')),
        ("'IN'", re.compile('IN')),
        ('"/"', re.compile('/')),
        ('";"', re.compile(';')),
        ('END', re.compile('[$;]')),
        ('NUM', re.compile('[0-9]+')),
        ('ID', re.compile('[a-zA-Z_][a-zA-Z0-9_-]*')),
        ('SP', re.compile('\\\\s')),
        ('SINGLE_QUOTED_STRING', re.compile("[^']*")),
        ('DOT', re.compile('\\.')),
        ('\\s+', re.compile('\\s+')),
        ('^(\\s+)*$', re.compile('^(\\s+)*$')),
        ('[ \t\r\n]+', re.compile('[ \t\r\n]+')),
        ('/\\*(.|\r?\n)+?\\*/', re.compile('/\\*(.|\r?\n)+?\\*/')),
        ('--.*?\r?\n', re.compile('--.*?\r?\n')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,['\\s+', '^(\\s+)*$', '[ \t\r\n]+', '/\\*(.|\r?\n)+?\\*/', '--.*?\r?\n'],str)

class plsql(yappsrt.Parser):
    Context = yappsrt.Context
    def goal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'goal', [])
        expr = self.expr(_context)
        END = self._scan('END')

    def expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'expr', [])
        _token = self._peek("'INSERT'", "'CREATE'")
        if _token == "'INSERT'":
            insert_statement = self.insert_statement(_context)
            _token = self._peek('";"', '"/"')
            if _token == '";"':
                self._scan('";"')
            else: # == '"/"'
                self._scan('"/"')
            return insert_statement
        else: # == "'CREATE'"
            source_declaration = self.source_declaration(_context)
            return source_declaration

    def identifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'identifier', [])
        ID = self._scan('ID')
        result = Identifier(id=ID)
        _token = self._peek("'IN'", "'OUT'", 'ID', 'DOT', "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', '"\'"', 'NUM', "','", "'\\\\)'")
        if self._peek("'IN'", "'OUT'", 'DOT', "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', '"\'"', 'NUM', "','", "'\\\\)'", 'ID') in ["'IN'", "'OUT'"]:
            _token = self._peek("'IN'", "'OUT'")
            if _token == "'IN'":
                self._scan("'IN'")
                if self._peek("'OUT'", 'ID') == "'OUT'":
                    self._scan("'OUT'")
            else: # == "'OUT'"
                self._scan("'OUT'")
            ID = self._scan('ID')
            result.type = ID
        else: # in ['DOT', "'VALUES'", '"IS"', '"\'"', "','"]
            if self._peek('ID', 'DOT', "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', '"\'"', 'NUM', "','", "'\\\\)'") == 'ID':
                ID = self._scan('ID')
                result.alias = ID
        _token = self._peek('DOT', "'\\\\('", "'VALUES'", 'END', '"IS"', '"AS"', '"\'"', 'NUM', "','", "'\\\\)'", 'ID')
        if _token != 'DOT':
            pass
        else: # == 'DOT'
            DOT = self._scan('DOT')
            ID = self._scan('ID')
            result = Identifier(id=ID, parent=result)
        return result

    def QUOTED_STRING(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'QUOTED_STRING', [])
        self._scan('"\'"')
        SINGLE_QUOTED_STRING = self._scan('SINGLE_QUOTED_STRING')
        self._scan('"\'"')
        return "'%s'" % SINGLE_QUOTED_STRING

    def LITERAL(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'LITERAL', [])
        _token = self._peek('"\'"', 'NUM')
        if _token == '"\'"':
            QUOTED_STRING = self.QUOTED_STRING(_context)
            return QUOTED_STRING
        else: # == 'NUM'
            NUM = self._scan('NUM')
            return int(NUM)

    def list_value(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'list_value', [])
        _token = self._peek('"\'"', 'NUM', 'ID')
        if _token != 'ID':
            LITERAL = self.LITERAL(_context)
            return LITERAL
        else: # == 'ID'
            callable = self.callable(_context)
            return callable

    def list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'list', [])
        result = []
        self._scan("'\\\\('")
        while self._peek("'\\\\)'", '"\'"', 'NUM', "','", 'ID') != "'\\\\)'":
            _token = self._peek('"\'"', 'NUM', "','", 'ID')
            if _token != "','":
                list_value = self.list_value(_context)
                result.append(list_value)
            else: # == "','"
                self._scan("','")
                list_value = self.list_value(_context)
                result.append(list_value)
        if self._peek() not in ["'\\\\)'", '"\'"', 'NUM', "','", 'ID']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\'"', 'NUM', "','", "'\\\\)'", 'ID']))
        self._scan("'\\\\)'")
        return result

    def insert_base(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'insert_base', [])
        self._scan("'INSERT'")
        self._scan("'INTO'")
        identifier = self.identifier(_context)
        return identifier

    def insert_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'insert_statement', [])
        sqlobject = InsertStatement()
        insert_base = self.insert_base(_context)
        sqlobject.table = insert_base
        _token = self._peek("'\\\\('", "'VALUES'")
        if _token == "'VALUES'":
            columns = []
        else: # == "'\\\\('"
            list = self.list(_context)
            columns = list
        sqlobject.columns = columns
        self._scan("'VALUES'")
        list = self.list(_context)
        sqlobject.values = list
        return sqlobject

    def callable(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'callable', [])
        identifier = self.identifier(_context)
        result = identifier
        if self._peek("'\\\\('", 'END', '"IS"', '"AS"', '"\'"', 'NUM', "','", "'\\\\)'", 'ID') == "'\\\\('":
            list = self.list(_context)
            result = CallableStatement(object=identifier.parent, name=identifier.id, arguments=list)
        return result

    def object_type(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'object_type', [])
        _token = self._peek("'FUNCTION'", "'PROCEDURE'", "'PACKAGE'")
        if _token == "'FUNCTION'":
            self._scan("'FUNCTION'")
            result = 'FUNCTION'
        elif _token == "'PROCEDURE'":
            self._scan("'PROCEDURE'")
            result = 'PROCEDURE'
        else: # == "'PACKAGE'"
            self._scan("'PACKAGE'")
            result = 'PACKAGE'
            if self._peek("'BODY'", 'ID') == "'BODY'":
                self._scan("'BODY'")
                result = 'PACKAGE BODY'
        return result

    def source_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'source_declaration', [])
        self._scan("'CREATE'")
        if self._peek("'OR'", "'FUNCTION'", "'PROCEDURE'", "'PACKAGE'") == "'OR'":
            self._scan("'OR'")
            self._scan("'REPLACE'")
        object_type = self.object_type(_context)
        result = Source(type=object_type)
        callable = self.callable(_context)
        result.id = callable
        _token = self._peek('END', '"IS"', '"AS"')
        if _token == 'END':
            END = self._scan('END')
        elif _token == '"IS"':
            self._scan('"IS"')
        else: # == '"AS"'
            self._scan('"AS"')
        return result


def parse(rule, text):
    P = plsql(plsqlScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps


